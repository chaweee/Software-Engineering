<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 1 - Software Engineering</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <section>
        <h1>Integration with the Web</h1>
        <article>
            <p>There is an incredible amount of information on software engineering available on the Web and some people have questioned if textbooks like this one are still needed. However, the quality of available information is very patchy, information is sometimes presented badly and it can be hard to find the information that you need. Consequently, I believe that textbooks still have an important role to play in learning. They serve as a roadmap to the subject and allow information on method and techniques to be organized and presented in a coherent and readable way. They also provide a starting point for deeper exploration of the research literature and material available on the Web.</p>
            
            <p>I strongly believe that textbooks have a future but only if they are integrated with and add value to material on the Web. This book has therefore been designed as a hybrid print/web text in which core information in the printed edition is linked to supplementary material on the Web. Almost all chapters include specially written 'web sections' that add to the information in that chapter. There are also four 'web chapters' on topics that I have not covered in the print version of the book.</p>
            
            <p>The website that is associated with the book is:</p>
            <h3><a href="">http://www.SoftwareEngineering-9.com</a></h3>
            
            <p>The book's web has four principal components:</p>
            <ol>
                <li>Web sections These are extra sections that add to the content presented in each chapter. These web sections are linked from breakout boxes in each chapter.</li>
                <li>Web chapters There are four web chapters covering formal methods, interaction design, documentation, and application architectures. I may add other chapters on new topics during the lifetime of the book.</li>
                <li>Material for instructors The material in this section is intended to support people who are teaching software engineering. See the "Support Materials" section in this Preface.</li>
                <li>Case studies These provide additional information about the case studies used in the book (insulin pump, mental health-care system, wilderness weather system) as well as information about further case studies, such as the failure of the Ariane 5 launcher.</li>
            </ol>
            
            <p>As well as these sections, there are also links to other sites with useful material on software engineering, further reading, blogs, newsletters, etc. I welcome your constructive comments and suggestions about the book and the website. You can contact me at ian@SoftwareEngineering-9.com. Please include [SE9] in the subject of your message. Otherwise, my spam filters will probably reject your mail and you will not receive a reply. I do not have time to help students with their homework, so please don't ask.</p>
        </article>
    </section>

    <section>
        <h1>Readership</h1>
        <article>
            <p>The book is primarily aimed at university and college students taking introductory and advanced courses in software and systems engineering. Software engineers in the industry may find the book useful as general reading and as a means of updating their knowledge on topics such as software reuse, architectural design, dependability and security, and process improvement. I assume that readers have completed an introductory programming course and are familiar with programming terminology.</p>
        </article>
    </section>

    <section>
        <h1>Changes from Previous Editions</h1>
        <article>
            <p>The book is primarily aimed at university and college students taking introductory and advanced courses in software and systems engineering. Software engineers in the industry may find the book useful as general reading and as a means of updating their knowledge on topics such as software reuse, architectural design, dependability and security, and process improvement. I assume that readers have completed an introductory programming course and are familiar with programming terminology.</p>
            
            <ol>
                <li>The move from a print-only book to a hybrid print/web book with the web material tightly integrated with the sections in the book. This has allowed me to reduce the number of chapters in the book and to focus on core material in each chapter.</li>
                <li>Complete restructuring to make it easier to use the book in teaching software engineering. The book now has four rather than eight parts and each part may be used on its own or in combination with other parts as the basis of a software engineering course. The four parts are an introduction to software engineering, dependability and security, advanced software engineering, and software engineering management</li>
                <li>Several topics from previous editions are presented more concisely in a single chapter, with extra material moved onto the Web.</li>
                <li>Additional web chapters, based on chapters from previous editions that I have not included here, are available on the Web.</li>
                <li>I have updated and revised the content in all chapters. I estimate that between 30% and 40% of the text has been completely rewritten.</li>
                <li>I have added new chapters on agile software development and embedded systems.</li>
                <li>As well as these new chapters, there is new material on model-driven engineering, open source development, test-driven development, Reason's Swiss Cheese model, dependable systems architectures, static analysis and model checking, COTS reuse, software as a service, and agile planning</li>
                <li>A new case study on a patient record system for patients who are undergoing treatment for mental health problems has been used in several chapters.</li>
            </ol>
        </article>
    </section>

    <section>
        <h1>Using Book for Teaching</h1>
        <article>
            <p>I have designed the book so that it can be used in three different types of software engineering courses:</p>
            <ol>
                <li>General introductory courses in software engineering The first part of the book has been designed explicitly to support a one-semester course in introductory software engineering.</li>
                <li>Introductory or intermediate courses on specific software engineering topics You can create a range of more advanced courses using the chapters in Parts 2â€“4. For example, I have taught a course in critical systems engineering using the chapters in Part 2 plus chapters on quality management and configuration management.</li>
                <li>More advanced courses in specific software engineering topics In this case, the chapters in the book form a foundation for the course. These are then supplemented with further reading that explores the topic in more detail. For example, a course on software reuse could be based around Chapters 16, 17, 18, and 19.</li>
            </ol>
            <p>More information about using the book for teaching, including a comparison with previous editions, is available on the book's website.</p>
        </article>
    </section>

    <section>
        <h1>Support Materials</h1>
        <article>
            <p>A wide range of support material is available to help people using the book for teaching software engineering courses. This includes:</p>
            <ul>
                <li>PowerPoint presentations for all of the chapters in the book.</li>
                <li>Figures in PowerPoint.</li>
                <li>An instructor's guide that gives advice on how to use the book in different courses and explains the relationship between the chapters in this edition and previous editions.</li>
                <li>Further information on the book's case studies.</li>
                <li>Additional case studies that may be used in software engineering courses.</li>
                <li>Additional PowerPoint presentations on systems engineering.</li>
                <li>Four web chapters covering formal methods, interaction design, application architectures, and documentation.</li>
            </ul>
            <p>All of this material is available free to readers of the book from the book's website or from the Pearson support site below. Additional material for instructors is available on a restricted basis to accredited instructors only:</p>
            <ul>
                <li>Model answers to selected end-of-chapter exercises.</li>
                <li>Quiz questions and answers for each chapter</li>
            </ul>
            <p>All support material, including restricted material, is available from:</p>
            <a href="">http://www.pearsonhighered.com/sommerville/</a>
            <p>Instructors using the book for teaching may obtain a password to access restricted material by registering at the Pearson website, by contacting their local Pearson representative, or by requesting a password by e-mail from computing@aw.com. Passwords are not available from the author.</p>
        </article>
    </section>

    <section>
        <h1>Acknowledgments</h1>
        <article>
            <p>A large number of people have contributed over the years to the evolution of this book and I'd like to thank everyone (reviewers, students, and book users) who have commented on previous editions and made constructive suggestions for change. I'd particularly like to thank my family (Anne, Ali, and Jane) for their help and support while the book was being written. A big thank-you especially to my daughter, Jane, who discovered a talent for proofreading and editing. She was tremendously helpful in reading the entire book and did a great job spotting and fixing a large number of typos and grammatical errors.</p>
            <p>Ian Sommerville <br> October 2009</p>
        </article>
    </section>

    <section>
        <article>
            <img src="assets/part1.png" alt="Part 1 Introduction">
            <p>My aim in this part of the book is to provide a general introduction to software engineering. I introduce important concepts such as software processes and agile methods, and describe essential software development activities, from initial software specification through to system evolution. The chapters in this part have been designed to support a one-semester course in software engineering.</p>
            
            <p>Chapter 1 is a general introduction that introduces professional software engineering and defines some software engineering concepts. I have also written a brief discussion of ethical issues in software engineering. I think that it is important for software engineers to think about the wider implications of their work. This chapter also introduces three case studies that I use in the book, namely a system for managing records of patients undergoing treatment for mental health problems, a control system for a portable insulin pump and a wilderness weather system.</p>
            
            <p>Chapters 2 and 3 cover software engineering processes and agile development. In Chapter 2, I introduce commonly used generic software process models, such as the waterfall model, and I discuss the basic activities that are part of these processes. Chapter 3 supplements this with a discussion of agile development methods for software engineering. I mostly use Extreme Programming as an example of an agile method but also briefly introduce Scrum in this chapter.</p>
            
            <p>The remainder of the chapters in this part are extended descriptions of the software process activities that will be introduced in Chapter 2. Chapter 4 covers the critically important topic of requirements engineering, where the requirements for what a system should do are defined. Chapter 5 introduces system modeling using the UML, where I focus on the use of use case diagrams, class diagrams, sequence diagrams, and state diagrams for modeling a software system. Chapter 6 introduces architectural design and I discuss the importance of architecture and the use of architectural patterns in software design.</p>
            
            <p>Chapter 7 introduces object-oriented design and the use of design patterns. I also introduce important implementation issues hereâ€”reuse, configuration management, and host-target development and discuss open source development. Chapter 8 focuses on software testing from unit testing during system development to the testing of software releases. I also discuss the use of test-driven developmentâ€”an approach pioneered in agile methods but which has wide applicability. Finally, Chapter 9 presents an overview of software evolution issues. I cover evolution processes, software maintenance, and legacy system management.</p>
        </article>
    </section>

    <section>
        <h1>Objectives</h1>
        <article>
            <p>The objectives of this chapter are to introduce software engineering and to provide a framework for understanding the rest of the book. When you have read this chapter you will:</p>
            <ul>
                <li>understand what software engineering is and why it is important;</li>
                <li>understand that the development of different types of software systems may require different software engineering techniques;</li>
                <li>understand some ethical and professional issues that are important for software engineers;</li>
                <li>have been introduced to three systems, of different types, that will be used as examples throughout the book.</li>
            </ul>
            
            <h3>Contents</h3>
            <h5>1.1 Professional software development</h5>
            <h5>1.2 Software engineering ethics</h5>
            <h5>1.3 Case studies</h5>
        </article>
    </section>

    <section>
        <article>
            <img src="assets/table1.png" alt="Chapter 1 Table">
            <h2>Chapter 1: Introduction</h2>
            <p>We can't run the modern world without software. National infrastructures and utilities are controlled by computer-based systems and most electrical products include a computer and controlling software. Industrial manufacturing and distribution is completely computerized, as is the financial system. Entertainment, including the music industry, computer games, and film and television, is software intensive. Therefore, software engineering is essential for the functioning of national and international societies.</p>
            
            <p>Software systems are abstract and intangible. They are not constrained by the properties of materials, governed by physical laws, or by manufacturing processes. This simplifies software engineering, as there are no natural limits to the potential of software. However, because of the lack of physical constraints, software systems can quickly become extremely complex, difficult to understand, and expensive to change.</p>
            
            <p>There are many different types of software systems, from simple embedded systems to complex, worldwide information systems. It is pointless to look for universal notations, methods, or techniques for software engineering because different types of software require different approaches. Developing an organizational information system is completely different from developing a controller for a scientific instrument. Neither of these systems has much in common with a graphics-intensive computer game. All of these applications need software engineering; they do not all need the same software engineering techniques.</p>
            
            <p>There are still many reports of software projects going wrong and 'software failures'. Software engineering is criticized as inadequate for modern software development. However, in my view, many of these so-called software failures are a consequence of two factors:</p>
            
            <ol>
                <li>Increasing demands As new software engineering techniques help us to build larger, more complex systems, the demands change. Systems have to be built and delivered more quickly; larger, even more complex systems are required; systems have to have new capabilities that were previously thought to be impossible. Existing software engineering methods cannot cope and new software engineering techniques have to be developed to meet new these new demands.</li>
                <li>Low expectations It is relatively easy to write computer programs without using software engineering methods and techniques. Many companies have drifted into software development as their products and services have evolved. They do not use software engineering methods in their everyday work. Consequently, their software is often more expensive and less reliable than it should be. We need better software engineering education and training to address this problem.</li>
            </ol>
            
            <p>Software engineers can be rightly proud of their achievements. Of course we still have problems developing complex software but, without software engineering, we would not have explored space, would not have the Internet or modern telecommunications. All forms of travel would be more dangerous and expensive. Software engineering has contributed a great deal and I am convinced that its contributions in the 21st century will be even greater.</p>
        </article>
    </section>

    <section>
        <h1>History of Software Engineering</h1>
        <article>
            <p>The notion of 'software engineering' was first proposed in 1968 at a conference held to discuss what was then called the 'software crisis' (Naur and Randell, 1969). It became clear that individual approaches to program development did not scale up to large and complex software systems. These were unreliable, cost more than expected, and were delivered late. Throughout the 1970s and 1980s, a variety of new software engineering techniques and methods were developed, such as structured programming, information hiding and object-oriented development. Tools and standard notations were developed and are now extensively used.</p>
            <a href="">http://www.SoftwareEngineering-9.com/Web/History/</a>
        </article>
    </section>

    <section>
        <h1>1.1 Professional Software Development</h1>
        <article>
            <h2>1.1.1 What is software?</h2>
            <p>Many people think that software is simply another word for computer programs. However, when we are talking about software engineering, software is not just the programs themselves but also all associated documentation and configuration data that is required to make these programs operate correctly. A professionally developed software system is often more than a single program. The system usually consists of a number of separate programs and configuration files that are used to set up these programs. It may include system documentation, which describes the structure of the system; user documentation, which explains how to use the system, and websites for users to download recent product information.</p>
            
            <img src="assets/table2.png" alt="Software Components">
            
            <h2>1.1.2 Software products</h2>
            <p>There are two kinds of software products:</p>
            <ul>
                <li><b>Generic products</b> â€“ These are stand-alone systems that are produced by a development organization and sold on the open market to any customer who is able to buy them. Examples of this type of product include software for PCs such as databases, word processors, drawing packages, and project management tools.</li>
                <li><b>Customized (or bespoke) products</b> â€“ These are systems that are commissioned by a particular customer. A software contractor develops the software especially for that customer. Examples include control systems for electronic devices, systems written to support a particular business process, and air traffic control systems.</li>
            </ul>
            
            <p>An important difference between these types of software is that, in generic products, the organization that develops the software controls the software specification. For custom products, the specification is usually developed and controlled by the organization that is buying the software. The software developers must work to that specification.</p>
            
            <p>However, the distinction between these system product types is becoming increasingly blurred. More and more systems are now being built with a generic product as a base, which is then adapted to suit the requirements of a customer. Enterprise Resource Planning (ERP) systems, such as the SAP system, are the best examples of this approach. Here, a large and complex system is adapted for a company by incorporating information about business rules and processes, reports required, and so on.</p>
            
            <h2>1.1.3 Software engineering and the Web</h2>
            <p>The development of the World Wide Web has had a profound effect on all of our lives. Initially, the Web was primarily a universally accessible information store and it had little effect on software systems. These systems ran on local computers and were only accessible from within an organization. Around 2000, the Web started to evolve and more and more functionality was added to browsers. This meant that web-based systems could be developed where, instead of a special-purpose user interface, these systems could be accessed using a web browser. This led to the development of a vast range of new system products that delivered innovative services, accessed over the Web. These are often funded by adverts that are displayed on the user's screen and do not involve direct payment from users.</p>
            
            <p>As well as these system products, the development of web browsers that could run small programs and do some local processing led to an evolution in business and organizational software. Instead of writing software and deploying it on users' PCs, the software was deployed on a web server. This made it much cheaper to change and upgrade the software, as there was no need to install the software on every PC. It also reduced costs, as user interface development is particularly expensive. Consequently, wherever it has been possible to do so, many businesses have moved to web-based interaction with company software systems.</p>
            
            <p>The next stage in the development of web-based systems was the notion of web services. Web services are software components that deliver specific, useful functionality and which are accessed over the Web. Applications are constructed by integrating these web services, which may be provided by different companies. In principle, this linking can be dynamic so that an application may use different web services each time that it is executed. I cover this approach to software development in Chapter 19.</p>
            
            <p>In the last few years, the notion of 'software as a service' has been developed. It has been proposed that software will not normally run on local computers but will run on 'computing clouds' that are accessed over the Internet. If you use a service such as web-based mail, you are using a cloud-based system. A computing cloud is a huge number of linked computer systems that is shared by many users. Users do not buy software but pay according to how much the software is used or are given free access in return for watching adverts that are displayed on their screen.</p>
            
            <p>The advent of the web, therefore, has led to a significant change in the way that business software is organized. Before the web, business applications were mostly monolithic, single programs running on single computers or computer clusters. Communications were local, within an organization. Now, software is highly distributed, sometimes across the world. Business applications are not programmed from scratch but involve extensive reuse of components and programs.</p>
            
            <p>This radical change in software organization has, obviously, led to changes in the ways that web-based systems are engineered. For example:</p>
            <ol>
                <li>Software reuse has become the dominant approach for constructing web-based systems. When building these systems, you think about how you can assemble them from pre-existing software components and systems.</li>
            </ol>
        </article>
    </section>

    <section>
        <h1>1.2 Software Engineering Ethics</h1>
        <article>
            <img src="assets/table3.png" alt="Ethics Table">
            
            <p>Professional societies and institutions have an important role to play in setting ethical standards. Organizations such as the ACM, the IEEE (Institute of Electrical and Electronic Engineers), and the British Computer Society publish a code of professional conduct or code of ethics. Members of these organizations undertake to follow that code when they sign up for membership. These codes of conduct are generally concerned with fundamental ethical behavior.</p>
            
            <p>Professional associations, notably the ACM and the IEEE, have cooperated to produce a joint code of ethics and professional practice. This code exists in both a short form, shown in Figure 1.3, and a longer form (Gotterbarn et al., 1999) that adds detail and substance to the shorter version. The rationale behind this code is summarized in the first two paragraphs of the longer form:</p>
            
            <p>Computers have a central and growing role in commerce, industry, government, medicine, education, entertainment and society at large. Software engineers are those who contribute by direct participation or by teaching, to the analysis, specification, design, development, certification, maintenance and testing of software systems. Because of their roles in developing software systems, software engineers have significant opportunities to do good or cause harm, to enable others to do good or cause harm, or to influence others to do good or cause harm. To ensure, as much as possible, that their efforts will be used for good, software engineers must commit themselves to making software engineering a beneficial and respected profession. In accordance with that commitment, software engineers shall adhere to the following Code of Ethics and Professional Practice.</p>
            
            <p>The Code contains eight Principles related to the behaviour of and decisions made by professional software engineers, including practitioners, educators, managers, supervisors and policy makers, as well as trainees and students of the profession. The Principles identify the ethically responsible relationships in which individuals, groups, and organizations participate and the primary obligations within these relationships. The Clauses of each Principle are illustrations of some of the obligations included in these relationships. These obligations are founded in the software engineer's humanity, in special care owed to people affected by the work of software engineers, and the unique elements of the practice of software engineering. The Code prescribes these as obligations of anyone claiming to be or aspiring to be a software engineer.</p>
            
            <h3>Software Engineering Code of Ethics and Professional Practice</h3>
            <h4>ACM/IEEE-CS Joint Task Force on Software Engineering Ethics and Professional Practices</h4>
            
            <h4>PREAMBLE</h4>
            <p>The short version of the code summarizes aspirations at a high level of the abstraction; the clauses that are included in the full version give examples and details of how these aspirations change the way we act as software engineering professionals. Without the aspirations, the details can become legalistic and tedious; without the details, the aspirations can become high sounding but empty; together, the aspirations and the details form a cohesive code.</p>
            
            <p>Software engineers shall commit themselves to making the analysis, specification, design, development, testing and maintenance of software a beneficial and respected profession. In accordance with their commitment to the health, safety and welfare of the public, software engineers shall adhere to the following Eight Principles:</p>
            
            <ol>
                <li><b>PUBLIC</b> â€” Software engineers shall act consistently with the public interest.</li>
                <li><b>CLIENT AND EMPLOYER</b> â€” Software engineers shall act in a manner that is in the best interests of their client and employer consistent with the public interest.</li>
                <li><b>PRODUCT</b> â€” Software engineers shall ensure that their products and related modifications meet the highest professional standards possible.</li>
                <li><b>JUDGMENT</b> â€” Software engineers shall maintain integrity and independence in their professional judgment.</li>
                <li><b>MANAGEMENT</b> â€” Software engineering managers and leaders shall subscribe to and promote an ethical approach to the management of software development and maintenance.</li>
                <li><b>PROFESSION</b> â€” Software engineers shall advance the integrity and reputation of the profession consistent with the public interest.</li>
                <li><b>COLLEAGUES</b> â€” Software engineers shall be fair to and supportive of their colleagues.</li>
                <li><b>SELF</b> â€” Software engineers shall participate in lifelong learning regarding the practice of their profession and shall promote an ethical approach to the practice of the profession.</li>
            </ol>
            
            <p>Like other engineering disciplines, software engineering is carried out within a legal and social framework that limits the freedom of engineers. Software engineers must accept that their work affects many people and must behave in an honest and ethically responsible way if they are to be respected as professionals. Ethical behaviour is more than simply upholding the law but involves following a set of principles that are morally correct.</p>
            
            <p>The ACM/IEEE Code of Ethics is a set of principles that software engineers should follow. Some of the most important ethical responsibilities are:</p>
            <ul>
                <li>Confidentiality â€“ Respect the confidentiality of your employers or clients.</li>
                <li>Competence â€“ Only accept work that you are competent to perform.</li>
                <li>Intellectual property rights â€“ Respect the intellectual property of others.</li>
                <li>Computer misuse â€“ Do not use your technical skills to misuse other people's computers.</li>
            </ul>
            
            <p>Ethical dilemmas occur when different ethical principles conflict. For example, you may be asked to work on a project that you feel is outside your area of competence, or you may be asked to reveal confidential information. In such cases, you should discuss the situation with your managers and, if necessary, seek advice from professional organizations.</p>
        </article>
    </section>

    <section>
        <h1>1.3 Case Studies</h1>
        <article>
            <p>To illustrate software engineering concepts, I use examples from three different types of systems throughout the book. The reason why I have not used a single case study is that one of the key messages in this book is that software engineering practice depends on the type of systems being produced. I therefore choose an appropriate example when discussing concepts such as safety and dependability, system modeling, reuse, etc.</p>
            
            <p>The three types of systems that I use as case studies are:</p>
            <ol>
                <li>An embedded system This is a system where the software controls a hardware device and is embedded in that device. Issues in embedded systems typically include physical size, responsiveness, power management, etc. The example of an embedded system that I use is a software system to control a medical device.</li>
                <li>An information system This is a system whose primary purpose is to manage and provide access to a database of information. Issues in information systems include security, usability, privacy, and maintaining data integrity. The example of an information system that I use is a medical records system.</li>
                <li>A sensor-based data collection system This is a system whose primary purpose is to collect data from a set of sensors and process that data in some way. The key requirements of such systems are reliability, even in hostile environmental conditions, and maintainability. The example of a data collection system that I use is a wilderness weather station.</li>
            </ol>
            
            <p>I introduce each of these systems in this chapter, with more information about each of them available on the Web</p>
            
            <p>Throughout this book, three case studies are used to illustrate different aspects of software engineering:</p>
            <ol>
                <li><b>Insulin pump control system</b> â€“ A real-time embedded system that controls a medical device for people with diabetes. This system is safety-critical and must be designed and implemented to ensure that it always delivers the correct dose of insulin to the patient. The software in the insulin pump monitors the patient's blood sugar level and calculates the amount of insulin required. It then controls a motor that delivers the insulin through a needle into the patient's body. The system must be able to detect and respond to hardware failures, such as a blocked needle or a low battery, and must provide appropriate warnings to the user.</li>
                <li><b>Patient information system for mental health care</b> â€“ An information system for managing patient records in a mental health care setting. This system is used by doctors, nurses, and administrative staff to record and access information about patients, including their medical history, treatment plans, and progress notes. The system must ensure the confidentiality and security of patient data, support the workflow of the mental health care team, and provide timely access to information to support clinical decision-making. The system must also comply with relevant legal and ethical requirements for handling sensitive health information.</li>
                <li><b>Wilderness weather station</b> â€“ A data collection system that gathers weather data from remote locations. This system consists of a set of weather stations located in remote areas, each equipped with sensors to measure temperature, humidity, wind speed, and other environmental variables. The weather stations transmit their data to a central server via satellite or radio links. The central server stores the data and provides access to users via a web interface. The system must be reliable and robust, as the weather stations may be difficult to access for maintenance, and must be able to operate in harsh environmental conditions.</li>
            </ol>
            
            <img src="assets/table4.png" alt="Case Studies Table">
            
            <p>These case studies are described in more detail in later chapters and are used to demonstrate how software engineering techniques are applied in practice.</p>
            
            <img src="assets/table5.png" alt="Case Study Details">
        </article>
    </section>

    <section>
        <h1>Mental Health Care - Patient Management System (MHC-PMS)</h1>
        <article>
            <p>The nature of mental health problems is such that patients are often disorganized so may miss appointments, deliberately or accidentally lose prescriptions and medication, forget instructions, and make unreasonable demands on medical staff. They may drop in on clinics unexpectedly. In a minority of cases, they may be a danger to themselves or to other people. They may regularly change address or may be homeless on a long-term or short-term basis. Where patients are dangerous, they may need to be 'sectioned'â€”confined to a secure hospital for treatment and observation.</p>
            
            <p>Users of the system include clinical staff such as doctors, nurses, and health visitors (nurses who visit people at home to check on their treatment). Nonmedical users include receptionists who make appointments, medical records staff who maintain the records system, and administrative staff who generate reports.</p>
            
            <p>The system is used to record information about patients (name, address, age, next of kin, etc.), consultations (date, doctor seen, subjective impressions of the patient, etc.), conditions, and treatments. Reports are generated at regular intervals for medical staff and health authority managers. Typically, reports for medical staff focus on information about individual patients whereas management reports are anonymized and are concerned with conditions, costs of treatment, etc.</p>
            
            <h3>Key Features of the System:</h3>
            <ol>
                <li><b>Individual care management</b> - Clinicians can create records for patients, edit the information in the system, view patient history, etc. The system supports data summaries so that doctors who have not previously met a patient can quickly learn about the key problems and treatments that have been prescribed.</li>
                <li><b>Patient monitoring</b> - The system regularly monitors the records of patients that are involved in treatment and issues warnings if possible problems are detected. Therefore, if a patient has not seen a doctor for some time, a warning may be issued. One of the most important elements of the monitoring system is to keep track of patients who have been sectioned and to ensure that the legally required checks are carried out at the right time.</li>
                <li><b>Administrative reporting</b> - The system generates monthly management reports showing the number of patients treated at each clinic, the number of patients who have entered and left the care system, number of patients sectioned, the drugs prescribed and their costs, etc.</li>
            </ol>
            
            <p>Two different laws affect the system. These are laws on data protection that govern the confidentiality of personal information and mental health laws that govern the compulsory detention of patients deemed to be a danger to themselves or others. Mental health is unique in this respect as it is the only medical speciality that can recommend the detention of patients against their will. This is subject to very strict legislative safeguards. One of the aims of the MHC-PMS is to ensure that staff always act in accordance with the law and that their decisions are recorded for judicial review if necessary.</p>
            
            <p>As in all medical systems, privacy is a critical system requirement. It is essential that patient information is confidential and is never disclosed to anyone apart from authorized medical staff and the patient themselves. The MHC-PMS is also a safety-critical system as incorrect information or system failures could lead to patients not receiving appropriate treatment or being detained incorrectly.</p>
            
            <img src="assets/table6.png" alt="MHC-PMS Details">
        </article>
    </section>

    <section>
        <h1>Key Points</h1>
        <article>
            <ul>
                <li>Software engineering is an engineering discipline concerned with all aspects of software production.</li>
                <li>Essential software product attributes are maintainability, dependability, efficiency, and acceptability.</li>
                <li>The fundamental activities in software processes are specification, development, validation, and evolution.</li>
                <li>There are many different types of software systems and different application types require different development techniques.</li>
                <li>Professional software engineers should follow a code of ethics and professional practice.</li>
            </ul>
        </article>
    </section>
</body>
</html>
